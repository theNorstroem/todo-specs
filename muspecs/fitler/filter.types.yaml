- type: 'filter.Condition  #Filter condition'
  fields:
    fld: '* string:1 #Field'
    is: 'string:2 #The comparator like gt, eq,...'
    val: 'string:3 #The value as string, parse this for your field'
    aoc: '[] filter.Condition:4 #And bracket with ors inside '
  target: filter.proto

- type: 'filter.Filter  #Filter root object'
  fields:
    clause: '[] filter.Condition:1 #Root bracket with ors inside, this is the most complex but most flexible way to define a filter '
    flat: |-
      map<string,filter.Condition>:2
      #Shortcut to set filter conditions without nesting.
      It is up to you how the server handles the request.
      Examples for a flat filter a,b,c:
      - all active conditions *must* match (a && b && c).
      - all conditions are handled as or (a || b || c).
      - you build your own logic like (a && b) || c.
  target: filter.proto
